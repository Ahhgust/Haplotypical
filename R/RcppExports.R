# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' this parses a cigar string and an interval (positions 5-100 in the *genome* say)
#' and returns whether or not the interval exists in the string 
#' AND it fills out substringStart and substringStop with the substring
#' positions of said intervals in half-open coordinates.
#' half-open allows for 0-length intervals to be assessed 
#' (e.g., insertions that are polymorphic in populations and not found in the queried string)
NULL

#' Quick UMI NN search
#'
#' This takes a vector of UMIs and counts ; these must be sorted in descending order
#' It traverses the UMIs, and gives the index (1-based) for any UMI in which there is another
#' UMI that is of greater (or equally) abundance AND 1 nucleotide apart
#' Values of 0 correspond to no UMI that is more abundant and 1 nuc separated.
#' 
#' The current implementation is quadratic wrt to the number of UMIs... so beware!
#'  
#'
#' @param umis (vector of strings (UMI sequences))
#' @param counts (parallel vector of counts;the $ of times (reads) that the UMI was observed in)
#' @param tolerance (when 0, equal or more abundant is the criterion; l allows for "equal" to include 1-less)
#' 
#' @export
fastBoundedHammingRange1NN <- function(umis, counts, tolerance = 0L) {
    .Call(`_Haplotypical_fastBoundedHammingRange1NN`, umis, counts, tolerance)
}

#' Search a Hamming graph
#'
#' Returns vector of graph distances 
#' in particular, the distance of each sequence (toCompare)
#' to the graph using the Hamming distance
#' 
#'
#' @param hammingGraph (string (singular) from makeSequenceHammingGraph)
#' @param toCompare (vector of strings; must be over set {ACGT})
#' @param maxDist (set to <0 if no bound; otherwise the computation halts when maxDist differences found) 
#' 
#' @export
fastBoundedHammingGraphDist <- function(hammingGraph, toCompare, maxDist) {
    .Call(`_Haplotypical_fastBoundedHammingGraphDist`, hammingGraph, toCompare, maxDist)
}

#' Make a Hamming graph
#'
#' 
#' Conceptually, it takes a reference sequence and adds IUPAC
#' codes to it where substitutions occur
#' 
#' diffAllele encodes the sequence differences
#' and
#' positions give the index of the position
#' 
#' The actual encoding uses bit-operations instead, but the take-home is the same
#' Queries are then allowed to match any of the letters in the IUPAC encoding 
#'
#' @param refRS (The reference sequence)
#' @param diffAllele (vector of strings; must contain only single nucleotides)
#' @param positions (vector if integers; must contain the positions)
#' 
#' @export
makeSequenceHammingGraph <- function(refRS, diffAllele, positions) {
    .Call(`_Haplotypical_makeSequenceHammingGraph`, refRS, diffAllele, positions)
}

#' Naive and fast Hamming distance (max dist of 2)
#' 
#' This function computes a naive (and fast)
#' Hamming distance between query and target
#' It is only designed to be correct iff that distance < 3
#' and may use short circuit evaluation when the distance is >= 3
#' It optionally ignores homopolymers (e.g., AAAT == AT == distance of 0)
#' @param query (query sequence)
#' @param target (target sequence)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
fastCloseHammingPair <- function(query, target, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_fastCloseHammingPair`, query, target, ignoreHomopolymers)
}

#' Returns the size of indel between 2 reads. Only single indels are supported
#'
#' This function computes a naive (and fast)
#' "indel" distance. i.e., if the two reads are separated by a single indel whose
#' length is the distance between the two strings.
#' This function is an optimization of the common case of sequence comparisons
#' between reads from massively parallel sequencing that are from the same PCR/sequencing assay
#' in which case the distance between strings is almost always 1.
#' It optionally ignores homopolymers (e.g., AAAT == AT == distance of 0 between)
#' The size of the indel is returned iff they are separated by an indel.
#' otherwise -1 is returned
#' @param query (query sequence)
#' @param target (target sequence)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
fastCloseIndelPair <- function(query, target, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_fastCloseIndelPair`, query, target, ignoreHomopolymers)
}

#' Computes fast string distances when the strings are close.
#'
#' This function computes a bounded, naive (and fast)
#' Hamming distance between query and bunch of sequence targets (seqs)
#' It is only designed to be correct iff that distance < 3
#' and may use short circuit evaluation when the distance is >= 3
#' It optionally ignores homopolymers (e.g., AAAT == AT == distance of 0)
#' this version is vectorized (on seqs)
#' 
#' @param query (query sequence)
#' @param seqs (target sequences)
#' @param result (distance between seqs)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
fastCloseDistances <- function(query, seqs, result, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_fastCloseDistances`, query, seqs, result, ignoreHomopolymers)
}

#' A heuristic to estimate some network properties of PCR amplified sequences
#'
#' This function uses a heuristic to 
#' infer some very basic network properties on a bunch of sequences
#' We define a leaf to be some sequence with distance < 3 to some other sequence in the set
#' a sequence is a leaf iff:
#' If this is distance 1, then exactly one sequence is distance 1 away
#' If this is distance 2, then only one sequence is distance 2 away
#' if this property holds then the leafStats vector is populated with the index
#' of the allele (some index i in seqs where seqs[i] is the node that this allele is uniquely
#' connected to.
#' The second statistic is the degree. In networks the degree of some node (sequence in our case)
#' is the number of edges connected to that node. For us, it's the number of sequences where that
#' sequence is the argmin of the distance function (aka, a reverse nearest neighbor). 
#' As there may be ties, if some sequence is, say, distance 1 from two sequences, the 
#' node with the higher count (and lowest order amongst equal counts) is selected.
#' all of these network properties are assuming that the distance is small (Hamming < 3)
#' greater distances are evaluated separately.
#' @param seqs (these are unique sequences found at some loci)
#' @param counts (parallel array to seqs; the number of times a particular allele was observed)
#' @param leafStats (leaf indexes-- see description. This parallel to seqs
#' @param degree (same structure as leafStats, but estimates the degree of each allele)
#' @param minCoverage (smallest number of read-counts to consider)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
approximateNetworkStats <- function(seqs, counts, leafStats, degree, minCoverage = 10L, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_approximateNetworkStats`, seqs, counts, leafStats, degree, minCoverage, ignoreHomopolymers)
}

#' Alignment-assisted STRait Razor in R
#'
#' This is an alignment-assisted version of STRait Razor. See:
#' <https://doi.org/10.1016/j.fsigen.2013.04.005>
#' and for shameless self promotion, see:
#' <https://doi.org/10.1016/j.fsigen.2017.05.008>
#' It is used to query a given locus, usually a short tandem repeat, and for it to return the variation in and around the repeat.
#' It is typically applied to DNA that has been PCR amplified.
#' STRait Razor solves this problem by just grabbing the sequence around where varaition is known to exist. 
#' The previous versions used "anchors" (e.g., primers) to grab the sequences associated with a known locus
#' This version uses genomic coordinates. You can optionally query for the entire genomic region, which gives you functionally
#' equivalent allele calls as the prevous versions of STRait Razor. You can optionally also mask out regions (troublesome homopolymers)
#' or you can use it to associate SNP calls in the flanking regions (which are well-aligned) with the STR region itself.
#' Or even to evaluate the co-association of alleles (e.g., physical phase)
#' As input the algorithm expects DNA sequences (seqs) 
#' that have been aligned (cigars)
#' to a reference genome (seqStarts)
#' And a set of queries are given (starts, stops)
#' and all reads that span all starts,stops are assessed
#' and the co-association of alleles in these blocks is assessed.    
#' @param seqs (query sequences)
#' @param cigars (query cigar operations (as per the Bam file format))
#' @param seqStarts (the base position in 1-based indexing of the first base in the alignment)
#' @param qWidths (the size or width of the alignment in the reference genome)
#' @param strands (the size or width of the alignment in the reference genome)
#' @param starts (of the regions you're intersted in, the 0-based start coordinate)
#' @param stops (of the regions you're intersted in, the 1-based stop coordinate)
#' @param regionStart (currently ignored; specifies the amplicon start/stop)
#' @param regionStop (currently ignored; specifies the amplicon start/stop)
#' @export
estimateHaplotypes <- function(seqs, cigars, seqStarts, qWidths, strands, starts, stops, regionStart, regionStop) {
    .Call(`_Haplotypical_estimateHaplotypes`, seqs, cigars, seqStarts, qWidths, strands, starts, stops, regionStart, regionStop)
}

#' Partitions a bed file. 
#'
#' This function takes two genomic intervals: one for a query (Q)
#' and another for the target (T).
#' The genomic intervals are of the form: chromosome, start, stop
#' which specifies a genomic range. Genomic ranges are in half-open coordinates.
#' See: http://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/
#' This creates a dataframe of the genomic intersection: every element in Q
#' is paired with every overlapping element in T.
#' This can be useful for associating a set of SNPs, say, with the amplicons in which they
#' arose.
#' @param chromsQ (query chromosome)
#' @param qStarts (query start coordinate. 0-based indexing)
#' @param qStops (query stop coordinate. 1-based indexing)
#' @param chromsT (target chromosome)
#' @param tStarts (target start coordinate. 0-based indexing)
#' @param tStops (target stop coordinate. 1-based indexing)
#' 
#' @export
partitionBed <- function(chromsQ, qStarts, qStops, chromsT, tStarts, tStops) {
    .Call(`_Haplotypical_partitionBed`, chromsQ, qStarts, qStops, chromsT, tStarts, tStops)
}

#' Given a description of the variants in a mixture, will generate a graph for use with later analysis.
#' 
#' @param refRS The reference sequence.
#' @param diffAllele The variant alleles for each difference.
#' @param position The positions in the reference: one based. Multiple events can be specified at a location.
#' @param etype The type of each event. Zero for replacement, one for insert, two for delete.
#' @return An opaque object for use with other methods in this package.
makeSequenceGraph <- function(refRS, diffAllele, position, etype) {
    .Call(`_Haplotypical_makeSequenceGraph`, refRS, diffAllele, position, etype)
}

#' Get the alignment table from a sequence to a graph.
#' 
#' @param sgrap The sequence graph in question.
#' @param query The sequence to align.
#' @return The alignment table.
alignSequenceGraph <- function(sgrap, query) {
    .Call(`_Haplotypical_alignSequenceGraph`, sgrap, query)
}

#' Get the edit distance from a sequence to a graph.
#' 
#' @param alnTable The result of the alignment.
#' @return The edit distance between the graph and the query.
getSequenceGraphEditDistance <- function(alnTable) {
    .Call(`_Haplotypical_getSequenceGraphEditDistance`, alnTable)
}

#' Note which nodes of the graph were not visited in an alignment.
#' 
#' @param sgrap The original graph.
#' @param alnTable The result of the alignment.
#' @return The nodes of the graph which were not visited.
getAlignmentMissedNodes <- function(sgrap, alnTable) {
    .Call(`_Haplotypical_getAlignmentMissedNodes`, sgrap, alnTable)
}

#' Prepare a string representation of the graph.
#' 
#' @param sgrap The sequence graph in question.
#' @return A string representation of the graph.
graphToString <- function(sgrap) {
    .Call(`_Haplotypical_graphToString`, sgrap)
}

#' Global pairwise alignment from the ksw2 library
#' 
#' This performs global pairwise alignment between a pair of sequences.
#' It returns the number of cigar operations
#' and the operations (M, I, D, optionally =/X if extended CIGARs are used)
#' (ops vector)
#' and the operation positions (opPos vector)
#'
#' Written by Heng Li with small tweaks by August Woerner
#'
#' @param Tseq (a string from the DNA alphabet; this is your target)
#' @param Qseq (like Tseq, but this is your query)
#' @param opPos (integer vector that is modified. It is the position of the cigar operation)
#' @param ops (these are the cigar operations themselves. there encoded as their integer representations, e.g., int('M')
#' @param sc_mch (the score for a match)
#' @param sc_mis (the penalty for a mismatch)
#' @param gapo (gap open penalty)
#' @param gape (gap extend penalty)
#' @param extended (changes M [Match or Mismatch] to =/X [Match or Mismatch, respectively] in the CIGAR)
#' @export
ksw2_gg_align <- function(Tseq, Qseq, opPos, ops, sc_mch = 1L, sc_mis = -2L, gapo = 2L, gape = 1L, extended = TRUE) {
    .Call(`_Haplotypical_ksw2_gg_align`, Tseq, Qseq, opPos, ops, sc_mch, sc_mis, gapo, gape, extended)
}

#' String reconstruction from a difference encoding...
#'
#' This takes the output from: ksw2_gg_align_df(Tseq, Qseq, ... )
#' and the reference (Tseq)
#' and uses it to re-create Qseq.
#' The main advantage of this approach is that particular types
#' of mutations can be filtered, as well as variants that fall in
#' particular regions.
#'
#' @param Tseq (the target sequence; e.g., the reference genome)
#' @param positions (1-based positions where the sequence differences are)
#' @param types (the types of events (0,1,2 for mismatch, deletions and insertions, respectively)
#' @param events (the nucleotides involved with the event; ignored if deletion)
#' @param initBuff (guess as to the final size of the query sequence. Overestimating is better than under)
#' @export
seqdiffs2seq <- function(Tseq, positions, types, events, initBuff = -1L) {
    .Call(`_Haplotypical_seqdiffs2seq`, Tseq, positions, types, events, initBuff)
}

#' Generates a diff between two sequences.
#' 
#' This is written by Heng Li with small tweaks by August Woerner
#' It performs global alignment (parameterized below)
#' and returns a data frame  of the sequence differences
#'
#' @param Tseq (the target sequence; e.g., the reference genome)
#' @param Qseq (the query sequence)
#' @param sc_mch (the score for a match)
#' @param sc_mis (the penalty for a mismatch)
#' @param gapo (gap open penalty)
#' @param gape (gap extend penalty)
#' @export
ksw2_seqs2seqdiffs <- function(Tseq, Qseq, sc_mch = 1L, sc_mis = -2L, gapo = 2L, gape = 1L) {
    .Call(`_Haplotypical_ksw2_seqs2seqdiffs`, Tseq, Qseq, sc_mch, sc_mis, gapo, gape)
}


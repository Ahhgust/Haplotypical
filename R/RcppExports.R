# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' this parses a cigar string and an interval (positions 5-100 in the *genome* say)
#' and returns whether or not the interval exists in the string 
#' AND it fills out substringStart and substringStop with the substring
#' positions of said intervals in half-open coordinates.
#' half-open allows for 0-length intervals to be assessed 
#' (e.g., insertions that are polymorphic in populations and not found in the queried string)
NULL

#' Naive and fast Hamming distance (max dist of 2)
#' 
#' This function computes a naive (and fast)
#' Hamming distance between query and target
#' It is only designed to be correct iff that distance < 3
#' and may use short circuit evaluation when the distance is >= 3
#' It optionally ignores homopolymers (e.g., AAAT == AT == distance of 0)
#' @param query (query sequence)
#' @param target (target sequence)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
fastCloseHammingPair <- function(query, target, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_fastCloseHammingPair`, query, target, ignoreHomopolymers)
}

#' Returns the size of indel between 2 reads. Only single indels are supported
#'
#' This function computes a naive (and fast)
#' "indel" distance. i.e., if the two reads are separated by a single indel whose
#' length is the distance between the two strings.
#' This function is an optimization of the common case of sequence comparisons
#' between reads from massively parallel sequencing that are from the same PCR/sequencing assay
#' in which case the distance between strings is almost always 1.
#' It optionally ignores homopolymers (e.g., AAAT == AT == distance of 0 between)
#' The size of the indel is returned iff they are separated by an indel.
#' otherwise -1 is returned
#' @param query (query sequence)
#' @param target (target sequence)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
fastCloseIndelPair <- function(query, target, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_fastCloseIndelPair`, query, target, ignoreHomopolymers)
}

#' Computes fast string distances when the strings are close.
#'
#' This function computes a bounded, naive (and fast)
#' Hamming distance between query and bunch of sequence targets (seqs)
#' It is only designed to be correct iff that distance < 3
#' and may use short circuit evaluation when the distance is >= 3
#' It optionally ignores homopolymers (e.g., AAAT == AT == distance of 0)
#' this version is vectorized (on seqs)
#' @param query (query sequence)
#' @param seqs (target sequences)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
fastCloseDistances <- function(query, seqs, result, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_fastCloseDistances`, query, seqs, result, ignoreHomopolymers)
}

#' A heuristic to estimate some network properties of PCR amplified sequences
#'
#' This function uses a heuristic to 
#' infer some very basic network properties on a bunch of sequences
#' We define a leaf to be some sequence with distance < 3 to some other sequence in the set
#' a sequence is a leaf iff:
#' If this is distance 1, then exactly one sequence is distance 1 away
#' If this is distance 2, then only one sequence is distance 2 away
#' if this property holds then the leafStats vector is populated with the index
#' of the allele (some index i in seqs where seqs[i] is the node that this allele is uniquely
#' connected to.
#' The second statistic is the degree. In networks the degree of some node (sequence in our case)
#' is the number of edges connected to that node. For us, it's the number of sequences where that
#' sequence is the argmin of the distance function (aka, a reverse nearest neighbor). 
#' As there may be ties, if some sequence is, say, distance 1 from two sequences, the 
#' node with the higher count (and lowest order amongst equal counts) is selected.
#' all of these network properties are assuming that the distance is small (Hamming < 3)
#' greater distances are evaluated separately.
#' @param seqs (these are unique sequences found at some loci)
#' @param counts (parallel array to seqs; the number of times a particular allele was observed)
#' @param leafStats (leaf indexes-- see description. This parallel to seqs
#' @param degree (same structure as leafStats, but estimates the degree of each allele)
#' @param ignoreHomopolymers (consecutive sequences of the same letter is treated as just 1 instance of that letter)
#' @export
approximateNetworkStats <- function(seqs, counts, leafStats, degree, minCoverage = 10L, ignoreHomopolymers = FALSE) {
    .Call(`_Haplotypical_approximateNetworkStats`, seqs, counts, leafStats, degree, minCoverage, ignoreHomopolymers)
}

#' Alignment-assisted STRait Razor in R
#'
#' This is an alignment-assisted version of STRait Razor. See:
#' <https://doi.org/10.1016/j.fsigen.2013.04.005>
#' and for shameless self promotion, see:
#' <https://doi.org/10.1016/j.fsigen.2017.05.008>
#' It is used to query a given locus, usually a short tandem repeat, and for it to return the variation in and around the repeat.
#' It is typically applied to DNA that has been PCR amplified.
#' STRait Razor solves this problem by just grabbing the sequence around where varaition is known to exist. 
#' The previous versions used "anchors" (e.g., primers) to grab the sequences associated with a known locus
#' This version uses genomic coordinates. You can optionally query for the entire genomic region, which gives you functionally
#' equivalent allele calls as the prevous versions of STRait Razor. You can optionally also mask out regions (troublesome homopolymers)
#' or you can use it to associate SNP calls in the flanking regions (which are well-aligned) with the STR region itself.
#' Or even to evaluate the co-association of alleles (e.g., physical phase)
#' As input the algorithm expects DNA sequences (seqs) 
#' that have been aligned (cigars)
#' to a reference genome (seqStarts)
#' And a set of queries are given (starts, stops)
#' and all reads that span all starts,stops are assessed
#' and the co-association of alleles in these blocks is assessed.    
#' @param seqs (query sequences)
#' @param cigars (query cigar operations (as per the Bam file format))
#' @param seqStarts (the base position in 1-based indexing of the first base in the alignment)
#' @param qWidths (the size or width of the alignment in the reference genome)
#' @param starts (of the regions you're intersted in, the 0-based start coordinate)
#' @param stops (of the regions you're intersted in, the 1-based stop coordinate)
#' @param regionStart (currently ignored; specifies the amplicon start/stop)
#' @param regionStop (currently ignored; specifies the amplicon start/stop)
#' @export
estimateHaplotypes <- function(seqs, cigars, seqStarts, qWidths, strands, starts, stops, regionStart, regionStop) {
    .Call(`_Haplotypical_estimateHaplotypes`, seqs, cigars, seqStarts, qWidths, strands, starts, stops, regionStart, regionStop)
}

#' Partitions a bed file. 
#'
#' This function takes two genomic intervals: one for a query (Q)
#' and another for the target (T).
#' The genomic intervals are of the form: chromosome, start, stop
#' which specifies a genomic range. Genomic ranges are in half-open coordinates.
#' See: http://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/
#' This creates a dataframe of the genomic intersection: every element in Q
#' is paired with every overlapping element in T.
#' This can be useful for associating a set of SNPs, say, with the amplicons in which they
#' arose.
#' @param chromsQ (query chromosome)
#' @param qStart (query start coordinate. 0-based indexing)
#' @param qStop (query stop coordinate. 1-based indexing)
#' @param chromsT (target chromosome)
#' @param tStart (target start coordinate. 0-based indexing)
#' @param tStop (target stop coordinate. 1-based indexing)
#' @export
partitionBed <- function(chromsQ, qStarts, qStops, chromsT, tStarts, tStops) {
    .Call(`_Haplotypical_partitionBed`, chromsQ, qStarts, qStops, chromsT, tStarts, tStops)
}

#' Global pairwise alignment from the ksw2 library
#' 
#' This performs global pairwise alignment between a pair of sequences.
#' It returns the number of cigar operations
#' and the operations (M, I, D, optionally =/X if extended CIGARs are used)
#' (ops vector)
#' and the operation positions (opPos vector)
#'
#' Written by Heng Li with small tweaks by August Woerner
#'
#' @param Tseq (a string from the DNA alphabet; this is your target)
#' @param Qseq (like Tseq, but this is your query)
#' @param opPos (integer vector that is modified. It is the position of the cigar operation)
#' @param ops (these are the cigar operations themselves. there encoded as their integer representations, e.g., int('M')
#' @param sc_mch (the score for a match)
#' @param sc_mis (the penalty for a mismatch)
#' @param gapo (gap open penalty)
#' @param gape (gap extend penalty)
#' @param extended (changes M [Match or Mismatch] to =/X [Match or Mismatch, respectively] in the CIGAR)
#' @export
ksw2_gg_align <- function(Tseq, Qseq, opPos, ops, sc_mch = 1L, sc_mis = -2L, gapo = 2L, gape = 1L, extended = TRUE) {
    .Call(`_Haplotypical_ksw2_gg_align`, Tseq, Qseq, opPos, ops, sc_mch, sc_mis, gapo, gape, extended)
}

#' String reconstruction from a difference encoding...
#'
#' This takes the output from: ksw2_gg_align_df(Tseq, Qseq, ... )
#' and the reference (Tseq)
#' and uses it to re-create Qseq.
#' The main advantage of this approach is that particular types
#' of mutations can be filtered, as well as variants that fall in
#' particular regions.
#'
#' @param Tseq (the target sequence; e.g., the reference genome)
#' @param positions (1-based positions where the sequence differences are)
#' @param types (the types of events (0,1,2 for mismatch, deletions and insertions, respectively)
#' @param events (the nucleotides involved with the event; ignored if deletion)
#' @param initBuff (guess as to the final size of the query sequence. Overestimating is better than under)
#' @export
seqdiffs2seq <- function(Tseq, positions, types, events, initBuff = -1L) {
    .Call(`_Haplotypical_seqdiffs2seq`, Tseq, positions, types, events, initBuff)
}

#' Generates a diff between two sequences.
#' 
#' This is written by Heng Li with small tweaks by August Woerner
#' It performs global alignment (parameterized below)
#' and returns a data frame  of the sequence differences
#'
#' @param Tseq (the target sequence; e.g., the reference genome)
#' @param Qseq (the query sequence)
#' @param sc_mch (the score for a match)
#' @param sc_mis (the penalty for a mismatch)
#' @param gapo (gap open penalty)
#' @param gape (gap extend penalty)
#' @export
ksw2_seqs2seqdiffs <- function(Tseq, Qseq, sc_mch = 1L, sc_mis = -2L, gapo = 2L, gape = 1L) {
    .Call(`_Haplotypical_ksw2_seqs2seqdiffs`, Tseq, Qseq, sc_mch, sc_mis, gapo, gape)
}

